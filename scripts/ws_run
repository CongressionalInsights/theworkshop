#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import shlex
import subprocess
import sys
import time
from datetime import datetime, timezone
from pathlib import Path

from twlib import ensure_dir, now_iso, resolve_project_root


def main() -> None:
    parser = argparse.ArgumentParser(description="Run a command and log structured execution to logs/execution.jsonl.")
    parser.add_argument("--project", help="Project root (defaults to nearest parent with plan.md)")
    parser.add_argument("--label", required=True, help="Short label for grouping")
    parser.add_argument("--tags", default="", help="Comma-separated tags")
    parser.add_argument("--work-item-id", default="", help="WI-... to attribute this command to")
    parser.add_argument("--phase", default="", help="Optional phase label (plan/execute/validate/etc.)")
    parser.add_argument("--cwd", default="", help="Override working directory (default: current)")
    parser.add_argument("--no-dashboard", action="store_true", help="Skip dashboard rebuild after logging")
    parser.add_argument("--", dest="dashdash", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("command", nargs=argparse.REMAINDER, help="Command to run after --")
    args = parser.parse_args()

    project_root = resolve_project_root(args.project)
    logs_dir = project_root / "logs"
    ensure_dir(logs_dir)

    cmd = args.command
    if cmd and cmd[0] == "--":
        cmd = cmd[1:]
    if not cmd:
        raise SystemExit("ws_run requires a command after --, e.g. scripts/ws_run --label x -- rg -n foo .")

    ts = now_iso()
    start = time.time()
    cwd = Path(args.cwd).expanduser().resolve() if args.cwd else Path.cwd().resolve()
    tags = [t.strip() for t in args.tags.split(",") if t.strip()]

    safe_label = "".join(c for c in args.label if c.isalnum() or c in "-_") or "cmd"
    stem = f"{datetime.now(timezone.utc).strftime('%Y%m%dT%H%M%SZ')}-{safe_label}"
    stdout_path = logs_dir / f"{stem}.stdout.txt"
    stderr_path = logs_dir / f"{stem}.stderr.txt"

    proc = subprocess.run(cmd, cwd=str(cwd), capture_output=True, text=True)
    stdout_path.write_text(proc.stdout or "", encoding="utf-8", errors="ignore")
    stderr_path.write_text(proc.stderr or "", encoding="utf-8", errors="ignore")

    end = time.time()
    entry = {
        "timestamp": ts,
        "end_timestamp": now_iso(),
        "duration_sec": int(round(end - start)),
        "label": args.label,
        "level": "INFO" if proc.returncode == 0 else "ERROR",
        "tags": tags,
        "work_item_id": args.work_item_id,
        "phase": args.phase,
        "command": " ".join([shlex.quote(c) for c in cmd]),
        "cwd": str(cwd),
        "exit_code": int(proc.returncode),
        "stdout": str(stdout_path),
        "stderr": str(stderr_path),
    }

    with (logs_dir / "execution.jsonl").open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(entry) + "\n")

    # Relay stdout/stderr to console for agent visibility
    if proc.stdout:
        print(proc.stdout, end="")
    if proc.stderr:
        print(proc.stderr, end="", file=sys.stderr)

    # Best-effort monitoring: rebuild dashboard after new execution log entries so
    # the browser auto-refresh has fresh state to display.
    if not args.no_dashboard:
        scripts_dir = Path(__file__).resolve().parent
        try:
            dash = subprocess.run(
                [sys.executable, str(scripts_dir / "dashboard_build.py"), "--project", str(project_root)],
                text=True,
                capture_output=True,
            )
            if dash.returncode != 0:
                print("warning: dashboard_build.py failed (best-effort).", file=sys.stderr)
                if dash.stderr:
                    print(dash.stderr, end="", file=sys.stderr)
        except Exception as e:
            print(f"warning: dashboard rebuild failed (best-effort): {e}", file=sys.stderr)

    raise SystemExit(proc.returncode)


if __name__ == "__main__":
    main()
